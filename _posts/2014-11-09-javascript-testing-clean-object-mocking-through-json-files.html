---
layout: post
title: Javascript Testing - Clean object mocking through JSON files
date: 2014-11-09 18:18:42.000000000 +05:00
categories:
- Anguar JS
- Angular JS
tags:
- AngularJS
- Jasmine
- mocking
- modules
- Software Development
- TDD
- unit testing
status: publish
type: post
published: true
meta:
  _wpas_skip_facebook: '1'
  _wpas_skip_google_plus: '1'
  _wpas_skip_twitter: '1'
  _wpas_skip_linkedin: '1'
  _wpas_skip_tumblr: '1'
  _wpas_skip_path: '1'
  _edit_last: '65775760'
  geo_public: '0'
  _oembed_9ea2ea08ef8eb67089be0d7a889c6555: '{{unknown}}'
  _oembed_0c70fcf2155ed535531e954c83209d6a: '{{unknown}}'
  _publicize_pending: '1'
author:
  login: mohammadumairkh
  email: mohammad.umair.k@gmail.com
  display_name: mohammadumairkh
  first_name: ''
  last_name: ''
---
<p class="p1"><span class="s1">Clean code is what is over my head for the past few days. Thanks to an excellent course by John Papa, Angular JS Patterns: Clean Code on Pluralsight, it has made think why there is a constant need to improve in the way we write code. One thing that struck my mind is the separation of concern, which is essential not only in understanding the code, but also in maintaining the code over long periods of time. I am a big fan of testing my javascript ( ... you should be too) and previously I have made an attempt to write clean tests to make them readable, scaleable and all that magic. The motivation behind writing that was a line we hear usually once every sprint, "Hey, lets add this .... ". My previous <a title="Cleaner and maintainable object mocking in unit testing through angular modules" href="http://mukhanblogs.wordpress.com/2014/05/03/cleaner-and-maintainable-object-mocking-in-unit-testing-through-angular-modules/" target="_blank">post</a> outlines one approach but this time I have decided to take it one level up.</span></p>
<p class="p1"><span class="s1">So, I will be using an overly simplistic Angular JS controller as a <em><strong>"proof of concept" </strong></em>to demonstrate how we can make our tests cleaner. Have a look at this controller, it contains a call to a service, through which it receives data and upon resolution of the promise, it attaches it to the view via the “vm” variable. </span></p>
<p class="p1"><em><span class="s1"><strong>Note:</strong> I am using the “Controller As” syntax so bye bye $scope and hello cleanliness.</span></em></p>
<p class="p1">[gist https://gist.github.com/mohammadumairkhan/693bc7db847bfdc7549d /]</p>
<p class="p1"><span class="s1">To test this controller I needed to mock the call to the “dataservice” which returns a mocked response. There are 3 ways we can mock the response.</span></p>
<p class="p1"><strong><span class="s1">The Good: <em>because it works!</em></span></strong></p>
<p class="p1"><span class="s1"> Declare the mock object in the test file as a javascript variable. This approach is common but it makes the test file feel like spaghetti. Its hard to find stuff and you need to copy over the mock objects if they are used in more than one file. <em>Yuck !</em></span></p>
<p class="p1"><strong><span class="s1">The Better: <strong><span class="s1"><em>because </em></span></strong></span></strong><em><strong><span class="s1">we are getting there ...</span></strong></em></p>
<p class="p1"><span class="s1"> Declare the mock object in a mock Angular JS factory and expose it via a return object. This approach was blogged earlier <a title="Cleaner and maintainable object mocking in unit testing through angular modules" href="http://mukhanblogs.wordpress.com/2014/05/03/cleaner-and-maintainable-object-mocking-in-unit-testing-through-angular-modules/" target="_blank">here</a>. The problem with this approach is that the mock Angular JS factory gets messier as the objects are added to it. It becomes one long/big file making it harder to maintain. <em>Okay .... </em></span></p>
<p class="p1"><strong><span class="s1">The Best: <em>Bingo!</em></span></strong></p>
<p class="p1"><span class="s1"> Declare the mock object in a JSON file, load it inside an Angular JS factory and expose it via a return object. I find this approach to be the best. Each object has its own file and is cleanly loaded into the Angular JS mock factory. The separation of objects into their own files make it a ton easier to maintain. <em>That's more like it ! </em></span></p>
<p class="p1"><span class="s1">In order to achieve the “Best” way to mock objects, we will make use of <strong>“jQuery-Jasmine”</strong> through which we will load the objects form the JSON file but it requires little bit of configuration so lets go through it step by step:</span></p>
<p><span class="s1"><b>1. Install jquery-jasmine as a development dependency via npm</b></span></p>
<p><span class="s1">Run “npm install jquery-jasmine --save-dev” on the root of your project via terminal/bash/cmd.</span></p>
<p><span class="s1"><b>2. Include jquery, jquery-jasmine as “files to be loaded”</b></span></p>
<p><span class="s1">Since I am using Karma to run my Jasmine tests, I only need a simple addition to the files array in my <b>karma.conf.js</b> file. See image below step 3.</span></p>
<p><span class="s1"><b>3. Include the JSON files as “files to be loaded”</b></span></p>
<p><span class="s1">Similar to the previous step, add the JSON files to the files array in the <b>karma.conf.js.</b></span></p>
<p>[caption id="attachment_101" align="aligncenter" width="618"]<a href="https://mukhanblogs.files.wordpress.com/2014/11/screen-shot-2014-11-09-at-11-28-13-pm.png"><img class="wp-image-101 size-full" src="assets/screen-shot-2014-11-09-at-11-28-13-pm.png" alt="karma.conf.js" width="618" height="633" /></a> karma.conf.js[/caption]</p>
<p><span class="s1"><b>4. Let Jasmine know from where to load the JSON files from</b></span></p>
<p><span class="s1">I have a separate Angular JS module for my mocks, so the place where I declare my module is the place I use to declare the relative path of my tests which would be loaded on the browser. </span></p>
<p><span class="s1">Note: This path is something karma makes when it loads the tests from the file system onto the browser and can change in the upcoming releases.</span></p>
<p>&nbsp;</p>
<p><a href="https://mukhanblogs.files.wordpress.com/2014/11/screen-shot-2014-11-10-at-12-06-06-am.png"><img class="aligncenter wp-image-107 size-full" src="assets/screen-shot-2014-11-10-at-12-06-06-am.png" alt="Screen Shot 2014-11-10 at 12.06.06 am" width="472" height="131" /></a></p>
<p><span class="s1">This is it for the configuration, now we need to create an Angular JS factory which would load the JSON files and expose them as objects in our test files. Here is the JSON file and how we load it into our mock Angular JS factory …</span></p>
<p class="p1">[gist https://gist.github.com/mohammadumairkhan/400797a818afce535098 /]</p>
<p class="p1">[gist https://gist.github.com/mohammadumairkhan/ff7e61e452cc5a35c00c /]</p>
<p class="p1">And finally.... This is how the tests look like.</p>
<p class="p1">I must say, transitioning from good to better to best feels a lot satisfactory.</p>
<p class="p1">[gist https://gist.github.com/mohammadumairkhan/fac9e35237b283813474 /]</p>
<p class="p1">All of you can now safely get up from your chairs and do this ....</p>
<p class="p1"><img class="aligncenter" src="assets/tumblr_mjrwr3XseO1rb9bkto2_250.gif" alt="" width="160" height="180" /></p>
